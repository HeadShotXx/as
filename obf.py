import os
import argparse

def xor_obfuscate(input_string, key):
    """XORs the input string with the given key."""
    # The input string is now read from a file, so it might not be utf-8.
    # Let's handle it as raw bytes.
    input_bytes = input_string.encode('utf-8', 'surrogatepass')
    return bytes([c ^ k for c, k in zip(input_bytes, key * (len(input_bytes) // len(key) + 1))])

def generate_rust_code(input_string, key_length=8):
    """Generates Rust code with an XOR-obfuscated string."""
    key = os.urandom(key_length)
    obfuscated_data = xor_obfuscate(input_string, key)

    # Format byte arrays for Rust
    obfuscated_array_str = ", ".join(map(str, obfuscated_data))
    key_array_str = ", ".join(map(str, key))

    rust_code = f"""
// Generated by Python XOR Obfuscator

// Decryption function
fn xor_decrypt(data: &[u8], key: &[u8]) -> String {{
    data.iter()
        .zip(key.iter().cycle())
        .map(|(&x, &y)| x ^ y)
        .map(|c| c as char)
        .collect()
}}

// Your main logic
fn main() {{
    // The obfuscated data and key
    let encrypted_data: [u8; {len(obfuscated_data)}] = [{obfuscated_array_str}];
    let key: [u8; {len(key)}] = [{key_array_str}];

    // Decrypt the string at runtime
    let decrypted_string = xor_decrypt(&encrypted_data, &key);

    // Now you can use `decrypted_string` in your application
    println!("The decrypted content is: {{}}", decrypted_string);

    // Example of how you might use it (e.g., as a command)
    // Be very careful with executing arbitrary strings!
    /*
    use std::process::Command;
    use std::str;

    println!("Executing command: {{}}", &decrypted_string);
    let output = Command::new("sh")
                         .arg("-c")
                         .arg(&decrypted_string)
                         .output()
                         .expect("Failed to execute command");

    println!("Status: {{}}", output.status);
    println!("Stdout: {{}}", str::from_utf8(&output.stdout).unwrap_or("..."));
    println!("Stderr: {{}}", str::from_utf8(&output.stderr).unwrap_or("..."));
    */
}}
"""
    return rust_code

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Obfuscate the content of a file and generate a Rust source file.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "-i", "--input",
        dest="input_file",
        required=True,
        help="Path to the input file (e.g., file.rc)."
    )
    parser.add_argument(
        "-o", "--output",
        dest="output_file",
        required=True,
        help="Path to the output Rust file (e.g., output.rs)."
    )
    parser.add_argument(
        "--key-length",
        type=int,
        default=8,
        help="The length of the random key for XOR obfuscation (default: 8)."
    )
    args = parser.parse_args()

    try:
        # Read the content from the input file
        with open(args.input_file, 'r', encoding='utf-8', errors='surrogatepass') as f:
            file_content = f.read()

        # Generate the Rust code with the obfuscated content
        rust_code = generate_rust_code(file_content, args.key_length)

        # Write the generated code to the output file
        with open(args.output_file, 'w', encoding='utf-8') as f:
            f.write(rust_code)

        print(f"Success: Obfuscated '{args.input_file}' and created '{args.output_file}'.")

    except FileNotFoundError:
        print(f"Error: The input file '{args.input_file}' was not found.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
