
// Generated by Python XOR Obfuscator

// Decryption function
fn xor_decrypt(data: &[u8], key: &[u8]) -> String {
    data.iter()
        .zip(key.iter().cycle())
        .map(|(&x, &y)| x ^ y)
        .map(|c| c as char)
        .collect()
}

// Your main logic
fn main() {
    // The obfuscated data and key
    let encrypted_data: [u8; 76] = [232, 96, 197, 17, 238, 175, 182, 229, 244, 99, 156, 17, 228, 185, 254, 173, 221, 119, 215, 23, 233, 168, 183, 239, 246, 95, 221, 24, 245, 191, 167, 160, 218, 118, 194, 21, 239, 175, 254, 173, 219, 96, 223, 25, 253, 178, 186, 160, 186, 92, 198, 21, 238, 168, 243, 208, 234, 96, 209, 17, 239, 175, 254, 238, 247, 123, 215, 4, 253, 184, 240, 229, 224, 106, 144, 126];
    let key: [u8; 8] = [152, 15, 178, 116, 156, 220, 222, 128];

    // Decrypt the string at runtime
    let decrypted_string = xor_decrypt(&encrypted_data, &key);

    // Now you can use `decrypted_string` in your application
    println!("The decrypted content is: {}", decrypted_string);

    // Example of how you might use it (e.g., as a command)
    // Be very careful with executing arbitrary strings!
    /*
    use std::process::Command;
    use std::str;

    println!("Executing command: {}", &decrypted_string);
    let output = Command::new("sh")
                         .arg("-c")
                         .arg(&decrypted_string)
                         .output()
                         .expect("Failed to execute command");

    println!("Status: {}", output.status);
    println!("Stdout: {}", str::from_utf8(&output.stdout).unwrap_or("..."));
    println!("Stderr: {}", str::from_utf8(&output.stderr).unwrap_or("..."));
    */
}
