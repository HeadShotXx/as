

use std::env;
use std::ffi::CString;
use std::fs;
use std::mem;
use std::ptr;
use winapi::shared::minwindef::DWORD;
use winapi::shared::minwindef::HMODULE;
use winapi::shared::minwindef::LPVOID;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::libloaderapi::GetProcAddress;
use winapi::um::libloaderapi::LoadLibraryA;
use winapi::um::memoryapi::VirtualAlloc;
use winapi::um::memoryapi::VirtualFree;
use winapi::um::memoryapi::VirtualProtect;
use winapi::um::processthreadsapi::FlushInstructionCache;
use winapi::um::processthreadsapi::GetCurrentProcess;
use winapi::um::winnt::IMAGE_BASE_RELOCATION;
use winapi::um::winnt::MEM_COMMIT;
use winapi::um::winnt::MEM_RELEASE;
use winapi::um::winnt::MEM_RESERVE;
use winapi::um::winnt::PAGE_EXECUTE_READ;
use winapi::um::winnt::PAGE_EXECUTE_READWRITE;
use winapi::um::winnt::PAGE_READONLY;
use winapi::um::winnt::PAGE_READWRITE;

#[inline(never)]
fn checksum_fjiooob_lq_bjr(data: &[u8]) -> u64 {
    let mut a = 1u64;
    let mut b = 0u64;
    for &byte in data {
        a = (a.wrapping_add(byte as u64)) % 65521;
        b = (b.wrapping_add(a)) % 65521;
    }
    (b << 32) | a
}

fn decode_onndfevvqanw(encrypted: &[u8], key: &[u8], expected_sum: u64) -> &'static str {
    let s: String = {
        use aes::cipher::{BlockDecrypt, KeyInit, generic_array::GenericArray};
        use aes::{Aes128, Aes192, Aes256};
        use base85; // using base85 for base85 decoding
        use bs58; // using bs58 for base58 decoding
        use base64::{engine::general_purpose, Engine as _};

        if key.len() < 88 { return Box::leak(String::from_utf8_lossy(encrypted).to_string().into_boxed_str()); }

        let xor_key = &key[0..16];
        let aes192_key = &key[16..40];
        let aes128_key = &key[40..56];
        let aes256_key = &key[56..88];

        let mut data = encrypted.to_vec();

        let cipher256 = Aes256::new(GenericArray::from_slice(aes256_key));
        for chunk in data.chunks_mut(16){
            let mut block = GenericArray::clone_from_slice(chunk);
            cipher256.decrypt_block(&mut block);
            chunk.copy_from_slice(&block);
        }

        let cipher128 = Aes128::new(GenericArray::from_slice(aes128_key));
        for chunk in data.chunks_mut(16){
            let mut block = GenericArray::clone_from_slice(chunk);
            cipher128.decrypt_block(&mut block);
            chunk.copy_from_slice(&block);
        }

        let cipher192 = Aes192::new(GenericArray::from_slice(aes192_key));
        for chunk in data.chunks_mut(16){
            let mut block = GenericArray::clone_from_slice(chunk);
            cipher192.decrypt_block(&mut block);
            chunk.copy_from_slice(&block);
        }

        if !data.is_empty() {
            let pad_len = data[data.len() - 1] as usize;
            if pad_len <= 16 && pad_len <= data.len() {
                data.truncate(data.len() - pad_len);
            }
        }

        let xor_decoded: Vec<u8> = data.iter().enumerate().map(|(i, &b)| b ^ xor_key[i % xor_key.len()]).collect();
        let hex_str = match String::from_utf8(xor_decoded) { Ok(s) => s, Err(_) => return Box::leak("".into()) };
        let base64_bytes = match hex::decode(&hex_str) { Ok(b) => b, Err(_) => return Box::leak(hex_str.into_boxed_str()) };
        let base64_str = match String::from_utf8(base64_bytes) { Ok(s) => s, Err(_) => return Box::leak("".into()) };
        let base32_bytes = match general_purpose::STANDARD.decode(&base64_str) { Ok(b) => b, Err(_) => return Box::leak(base64_str.into_boxed_str()) };
        let base32_str = match String::from_utf8(base32_bytes) { Ok(s) => s, Err(_) => return Box::leak("".into()) };
        let base58_bytes = match base32::decode(base32::Alphabet::Rfc4648 { padding: true }, &base32_str) { Some(b) => b, None => return Box::leak(base32_str.into_boxed_str()) };
        let base58_str = match String::from_utf8(base58_bytes) { Ok(s) => s, Err(_) => return Box::leak("".into()) };
        let base85_bytes = match bs58::decode(&base58_str).into_vec() { Ok(b) => b, Err(_) => return Box::leak(base58_str.into_boxed_str()) };
        let base85_str = match String::from_utf8(base85_bytes) { Ok(s) => s, Err(_) => return Box::leak("".into()) };
        let base45_bytes = match base85::decode(&base85_str) { Ok(b) => b, Err(_) => return Box::leak(base85_str.into_boxed_str()) };
        let base45_str = match String::from_utf8(base45_bytes) { Ok(s) => s, Err(_) => return Box::leak("".into()) };

        match base45::decode(&base45_str) {
            Ok(final_bytes) => {
                let runtime_sum = checksum_fjiooob_lq_bjr(&final_bytes);
                if runtime_sum != expected_sum {
                    // Tampering detected! Simulated volatile write (to valid memory) then abort.
                    unsafe {
                        let mut dummy: u8 = 0;
                        std::ptr::write_volatile(&mut dummy, 1);
                    }
                    std::process::abort();
                }
                String::from_utf8_lossy(&final_bytes).to_string()
            },
            Err(_) => base45_str,
        }
    };
    Box::leak(s.into_boxed_str())
}

     # [cfg (windows)]  # [cfg (windows)]  # [cfg (windows)]  # [cfg (windows)]  # [cfg (windows)]  # [cfg (windows)]  # [repr (C)] struct drjiff_g_o { e_magic : u16 , e_cblp : u16 , e_cp : u16 , e_crlc : u16 , e_cparhdr : u16 , e_minalloc : u16 , e_maxalloc : u16 , e_ss : u16 , e_sp : u16 , e_csum : u16 , e_ip : u16 , e_cs : u16 , e_lfarlc : u16 , e_ovno : u16 , e_res : [u16 ; 4] , e_oemid : u16 , e_oeminfo : u16 , e_res2 : [u16 ; 10] , e_lfanew : i32 , } # [repr (C)] struct cbhny_a_fg { machine : u16 , number_of_sections : u16 , time_date_stamp : u32 , pointer_to_symbol_table : u32 , number_of_symbols : u32 , size_of_optional_header : u16 , characteristics : u16 , } # [repr (C)] struct akgflxkw { magic : u16 , major_linker_version : u8 , minor_linker_version : u8 , size_of_code : u32 , size_of_initialized_data : u32 , size_of_uninitialized_data : u32 , address_of_entry_point : u32 , base_of_code : u32 , image_base : usize , section_alignment : u32 , file_alignment : u32 , major_operating_system_version : u16 , minor_operating_system_version : u16 , major_image_version : u16 , minor_image_version : u16 , major_subsystem_version : u16 , minor_subsystem_version : u16 , win32_version_value : u32 , size_of_image : u32 , size_of_headers : u32 , check_sum : u32 , subsystem : u16 , dll_characteristics : u16 , size_of_stack_reserve : usize , size_of_stack_commit : usize , size_of_heap_reserve : usize , size_of_heap_commit : usize , loader_flags : u32 , number_of_rva_and_sizes : u32 , } # [repr (C)] struct ww_wnpii_w { signature : u32 , file_header : cbhny_a_fg , optional_header : akgflxkw , } # [repr (C)] struct rcevcmxq { name : [u8 ; 8] , virtual_size : u32 , virtual_address : u32 , size_of_raw_data : u32 , pointer_to_raw_data : u32 , pointer_to_relocations : u32 , pointer_to_linenumbers : u32 , number_of_relocations : u16 , number_of_linenumbers : u16 , characteristics : u32 , } # [repr (C)] struct lgqb_k_hqi { virtual_address : u32 , size : u32 , } # [repr (C)] struct gpg_zonuc { original_first_thunk : u32 , time_date_stamp : u32 , forwarder_chain : u32 , name : u32 , first_thunk : u32 , } # [repr (C)] struct mpie_pmzm { hint : u16 , name : [u8 ; 1] , } # [repr (C)] struct h_gvckkdz { virtual_address : u32 , size_of_block : u32 , } # [repr (C)] struct moelxfai { characteristics : u32 , time_date_stamp : u32 , major_version : u16 , minor_version : u16 , name : u32 , base : u32 , number_of_functions : u32 , number_of_names : u32 , address_of_functions : u32 , address_of_names : u32 , address_of_name_ordinals : u32 , } # [repr (C)] struct asjtcxr_r { start_address_of_raw_data : u64 , end_address_of_raw_data : u64 , address_of_index : u64 , address_of_callbacks : u64 , size_of_zero_fill : u32 , characteristics : u32 , } const gr_gsbos_v : u32 = (47874602 + 488996310) ; const oewhc_dqz : u32 = (260002735 + 813739089) ; const oka_s_srtp : u32 = (807084428 + 1340399220) ; const bnqh_oo_rd : usize = 0 ; const meqdx_sve : usize = 1 ; const y_kuktdib : usize = 5 ; const yxrmjx_fx : usize = 9 ; const ow_nin_cse : usize = 10 ; const nsoeo_dgz : usize = (2 + 10) ; # [cfg (windows)] unsafe fn ftlkad_m_d (nt_headers : * const ww_wnpii_w , index : usize) -> * const lgqb_k_hqi { let optional_header_ptr = & (* nt_headers) . optional_header as * const akgflxkw ; let data_dir_ptr = (optional_header_ptr as usize + mem :: offset_of ! (ImageOptionalHeader64 , number_of_rva_and_sizes) + mem :: size_of :: < u32 > ()) as * const lgqb_k_hqi ; data_dir_ptr . add (index) } # [cfg (windows)] unsafe fn howtfr_qo (image_base : * mut u8 , section : & rcevcmxq) -> Result < () , String > { let characteristics = section . characteristics ; let mut protect = PAGE_READONLY ; if (characteristics & gr_gsbos_v) != 0 { if (characteristics & oka_s_srtp) != 0 { protect = PAGE_EXECUTE_READWRITE ; } else if (characteristics & oewhc_dqz) != 0 { protect = PAGE_EXECUTE_READ ; } } else if (characteristics & oka_s_srtp) != 0 { protect = PAGE_READWRITE ; } else if (characteristics & oewhc_dqz) != 0 { protect = PAGE_READONLY ; } let section_start = image_base . add (section . virtual_address as usize) ; let mut old_protect = 0 ; let result = VirtualProtect (section_start as LPVOID , section . virtual_size as usize , protect , & mut old_protect ,) ; if result == 0 { return Err (format ! ("Failed to set section protection (error: {})" , GetLastError ())) ; } Ok (()) } # [cfg (windows)] unsafe fn bjvzdabu (image_base : * mut u8 , nt_headers : * const ww_wnpii_w) -> Result < () , String > { let reloc_dir = ftlkad_m_d (nt_headers , y_kuktdib) ; if (* reloc_dir) . virtual_address == 0 { println ! ("[!] No relocations found") ; return Ok (()) ; } let preferred_base = (* nt_headers) . optional_header . image_base ; let delta = image_base as isize - preferred_base as isize ; if delta == 0 { println ! ("[+] No relocation needed (loaded at preferred base)") ; return Ok (()) ; } let mut reloc_ptr = image_base . add ((* reloc_dir) . virtual_address as usize) as * const h_gvckkdz ; let reloc_end = (reloc_ptr as usize + (* reloc_dir) . size as usize) as * const h_gvckkdz ; let mut reloc_count = 0 ; while (reloc_ptr as usize) < (reloc_end as usize) && (* reloc_ptr) . size_of_block > 0 { let count = ((* reloc_ptr) . size_of_block as usize - mem :: size_of :: < ImageBaseRelocation > ()) / 2 ; let entries = (reloc_ptr as usize + mem :: size_of :: < ImageBaseRelocation > ()) as * const u16 ; for i in 0 .. count { let entry = * entries . add (i) ; let reloc_type = entry >> (3 + 9) ; let offset = entry & (1784 + 2311) ; if reloc_type == 3 { let patch_addr = image_base . add ((* reloc_ptr) . virtual_address as usize + offset as usize) as * mut u32 ; * patch_addr = ((* patch_addr as isize) + delta) as u32 ; reloc_count += 1 ; } else if reloc_type == 10 { let patch_addr = image_base . add ((* reloc_ptr) . virtual_address as usize + offset as usize) as * mut u64 ; * patch_addr = ((* patch_addr as isize) + delta) as u64 ; reloc_count += 1 ; } } reloc_ptr = (reloc_ptr as usize + (* reloc_ptr) . size_of_block as usize) as * const h_gvckkdz ; } println ! ("[+] Processed {} relocations (delta: 0x{:x})" , reloc_count , delta) ; Ok (()) } # [cfg (windows)] unsafe fn rjf_l_duxd (image_base : * mut u8 , nt_headers : * const ww_wnpii_w) -> Result < () , String > { let import_dir = ftlkad_m_d (nt_headers , meqdx_sve) ; if (* import_dir) . virtual_address == 0 { println ! ("[!] No import table found") ; return Ok (()) ; } let mut import_desc = image_base . add ((* import_dir) . virtual_address as usize) as * const gpg_zonuc ; let mut dll_count = 0 ; while (* import_desc) . name != 0 { let dll_name_ptr = image_base . add ((* import_desc) . name as usize) ; let dll_name = std :: ffi :: CStr :: from_ptr (dll_name_ptr as * const i8) ; println ! ("[+] Loading: {:?}" , dll_name) ; let module = LoadLibraryA (dll_name_ptr as * const i8) ; if module . is_null () { return Err (format ! ("Failed to load DLL: {:?} (error: {})" , dll_name , GetLastError ())) ; } let mut thunk_ref = if (* import_desc) . original_first_thunk != 0 { image_base . add ((* import_desc) . original_first_thunk as usize) as * const usize } else { image_base . add ((* import_desc) . first_thunk as usize) as * const usize } ; let mut func_ref = image_base . add ((* import_desc) . first_thunk as usize) as * mut usize ; let mut func_count = 0 ; while * thunk_ref != 0 { let func_addr = if (* thunk_ref & (1 << (21 + 42))) != 0 { let ordinal = (* thunk_ref & (14735 + 50800)) as u16 ; GetProcAddress (module , ordinal as usize as * const i8) } else { let import_by_name = image_base . add (* thunk_ref as usize) as * const mpie_pmzm ; let func_name_ptr = & (* import_by_name) . name as * const u8 as * const i8 ; GetProcAddress (module , func_name_ptr) } ; if func_addr . is_null () { return Err (format ! ("Failed to import function (error: {})" , GetLastError ())) ; } * func_ref = func_addr as usize ; func_count += 1 ; thunk_ref = thunk_ref . add (1) ; func_ref = func_ref . add (1) ; } println ! ("  → Resolved {} functions" , func_count) ; dll_count += 1 ; import_desc = import_desc . add (1) ; } println ! ("[+] Imported {} DLLs" , dll_count) ; Ok (()) } # [cfg (windows)] unsafe fn uqckcg_d_n (image_base : * mut u8 , nt_headers : * const ww_wnpii_w) -> Result < () , String > { let tls_dir = ftlkad_m_d (nt_headers , yxrmjx_fx) ; if (* tls_dir) . virtual_address == 0 { return Ok (()) ; } println ! ("[*] Processing TLS callbacks...") ; let tls = image_base . add ((* tls_dir) . virtual_address as usize) as * const asjtcxr_r ; let callbacks_addr = (* tls) . address_of_callbacks as usize ; if callbacks_addr == 0 { return Ok (()) ; } let mut callback_ptr = callbacks_addr as * const usize ; let mut callback_count = 0 ; while * callback_ptr != 0 { let callback : extern "system" fn (LPVOID , DWORD , LPVOID) = mem :: transmute (* callback_ptr) ; callback (image_base as LPVOID , 1 , ptr :: null_mut ()) ; callback_count += 1 ; callback_ptr = callback_ptr . add (1) ; } println ! ("[+] Executed {} TLS callbacks" , callback_count) ; Ok (()) } # [cfg (windows)] unsafe fn libcjibq (image_base : * mut u8 , nt_headers : * const ww_wnpii_w) -> Result < () , String > { println ! ("[*] Finalizing section permissions...") ; let section_header_ptr = (nt_headers as * const ww_wnpii_w as usize + mem :: size_of :: < u32 > () + mem :: size_of :: < ImageFileHeader > () + (* nt_headers) . file_header . size_of_optional_header as usize) as * const rcevcmxq ; for i in 0 .. (* nt_headers) . file_header . number_of_sections { let section = & * section_header_ptr . offset (i as isize) ; let section_name = std :: str :: from_utf8 (& section . name) . unwrap_or (decode_onndfevvqanw (& [172 , 28 , 202 , 241 , 186 , 4 , 18 , 220 , 41 , 88 , 55 , 29 , 118 , 105 , 222 , 63 , 69 , 224 , 20 , 54 , 50 , 191 , 224 , 176 , 205 , 164 , 76 , 86 , 163 , 20 , 175 , 16 , 254 , 2 , 166 , 172 , 173 , 38 , 8 , 161 , 84 , 69 , 25 , 35 , 215 , 19 , 3 , 241 , 195 , 122 , 50 , 208 , 114 , 215 , 177 , 60 , 161 , 77 , 217 , 107 , 207 , 43 , 178 , 16] , & [135 , 30 , 64 , 193 , 228 , 103 , 175 , 9 , 239 , 114 , 73 , 133 , 114 , 65 , 233 , 129 , 184 , 9 , 174 , 13 , 138 , 43 , 57 , 138 , 93 , 180 , 112 , 131 , 201 , 63 , 15 , 79 , 247 , 36 , 218 , 249 , 230 , 152 , 164 , 116 , 38 , 42 , 195 , 19 , 65 , 2 , 12 , 57 , 188 , 81 , 214 , 153 , 79 , 182 , 87 , 57 , 130 , 73 , 83 , 237 , 202 , 223 , 68 , 147 , 117 , 160 , 69 , 171 , 225 , 34 , 151 , 242 , 207 , 12 , 108 , 177 , 241 , 102 , 79 , 198 , 153 , 75 , 153 , 100 , 186 , 203 , 39 , 48] , 1636382539966u64)) . trim_end_matches ('\0') ; howtfr_qo (image_base , section) ? ; let perms = if (section . characteristics & gr_gsbos_v) != 0 { "X" } else { "-" } . to_string () + if (section . characteristics & oewhc_dqz) != 0 { "R" } else { "-" } + if (section . characteristics & oka_s_srtp) != 0 { "W" } else { "-" } ; println ! ("  → {} [{}]" , section_name , perms) ; }  FlushInstructionCache (GetCurrentProcess () , image_base as LPVOID , (* nt_headers) . optional_header . size_of_image as usize) ; Ok (()) } # [cfg (windows)] unsafe fn gagxrcag (pe_data : & [u8]) -> Result < () , String > { println ! ("=== Advanced PE Memory Loader (x64 Only) ===\n") ; if pe_data . len () < mem :: size_of :: < ImageDosHeader > () { return Err (decode_onndfevvqanw (& [113 , 4 , 176 , 202 , 166 , 32 , 6 , 18 , 198 , 25 , 0 , 139 , 197 , 200 , 15 , 170 , 31 , 107 , 94 , 220 , 32 , 152 , 203 , 81 , 135 , 106 , 120 , 129 , 234 , 241 , 150 , 32 , 145 , 132 , 216 , 172 , 212 , 61 , 54 , 201 , 38 , 248 , 220 , 23 , 121 , 18 , 86 , 159 , 174 , 244 , 158 , 223 , 7 , 56 , 14 , 244 , 84 , 75 , 64 , 10 , 76 , 38 , 194 , 77 , 185 , 36 , 27 , 27 , 224 , 67 , 9 , 107 , 125 , 37 , 144 , 118 , 127 , 13 , 110 , 194 , 59 , 161 , 189 , 239 , 69 , 67 , 38 , 162 , 218 , 165 , 13 , 11 , 39 , 190 , 248 , 156 , 9 , 220 , 103 , 20 , 125 , 177 , 23 , 255 , 87 , 101 , 87 , 173 , 20 , 168 , 115 , 48 , 81 , 183 , 9 , 251 , 76 , 99 , 253 , 197 , 102 , 205 , 24 , 212 , 217 , 152 , 81 , 133 , 100 , 113 , 250 , 184 , 200 , 144 , 246 , 251 , 120 , 230 , 118 , 46 , 216 , 63 , 87 , 75 , 227 , 147 , 107 , 158 , 77 , 135 , 113 , 160 , 112 , 5 , 214 , 154 , 37 , 13 , 3 , 248 , 33 , 28 , 134 , 73 , 123 , 46 , 79 , 97 , 49 , 61 , 144 , 216 , 123 , 59 , 161 , 159 , 18 , 229 , 120 , 157 , 236 , 99 , 165 , 151 , 170 , 181 , 58 , 83 , 240 , 203 , 244 , 108 , 192 , 162 , 51 , 229 , 45 , 28 , 153 , 110 , 152 , 98 , 197 , 28 , 137 , 220 , 217 , 153 , 46 , 242 , 201 , 138 , 110 , 79 , 116 , 49 , 27 , 36 , 125 , 224 , 173 , 192 , 233 , 6 , 255 , 59 , 243 , 14 , 123 , 57 , 195 , 136 , 230 , 203 , 72 , 66 , 43 , 189 , 232 , 169 , 184 , 24 , 11 , 223 , 109 , 195 , 193 , 127 , 47 , 33 , 30 , 96 , 14 , 119 , 32 , 235 , 216 , 109 , 171 , 96 , 56 , 228 , 75 , 48 , 43 , 156 , 231 , 72 , 212 , 128 , 58 , 89 , 155 , 51 , 188 , 158 , 37 , 190 , 6 , 71 , 0 , 88 , 189 , 117 , 237 , 111 , 215 , 61 , 98 , 102 , 51 , 166 , 22 , 100 , 253 , 131 , 221 , 254 , 157 , 162 , 0 , 155 , 212 , 36 , 78 , 154 , 103 , 12 , 86 , 184 , 48 , 185 , 199 , 1 , 157 , 65 , 47 , 17 , 58 , 212 , 87 , 57 , 18 , 5 , 208 , 45 , 101 , 186 , 155 , 218 , 123 , 213 , 108 , 54 , 162 , 235 , 84 , 245 , 80 , 170 , 4 , 203 , 184 , 159 , 136 , 4 , 235 , 104 , 236 , 130 , 164 , 117 , 156 , 125 , 78 , 241 , 43 , 22 , 100 , 20 , 104 , 248 , 220 , 94 , 209 , 156 , 100 , 228 , 206 , 194 , 87 , 200 , 118 , 59 , 232 , 74 , 97 , 141 , 71 , 251 , 148 , 24 , 106 , 124 , 72 , 43 , 94 , 214 , 232 , 20 , 75 , 223 , 237 , 31 , 48 , 156 , 16 , 75 , 162 , 219 , 30 , 161 , 3 , 209 , 226 , 100 , 244 , 166 , 49 , 186 , 6 , 23 , 132 , 64 , 4 , 63] , & [240 , 224 , 230 , 90 , 51 , 88 , 240 , 146 , 214 , 130 , 210 , 243 , 253 , 98 , 216 , 58 , 220 , 216 , 30 , 142 , 218 , 35 , 84 , 102 , 72 , 147 , 246 , 207 , 254 , 5 , 5 , 20 , 67 , 56 , 225 , 129 , 32 , 223 , 76 , 192 , 86 , 239 , 42 , 42 , 97 , 24 , 25 , 162 , 143 , 22 , 63 , 42 , 147 , 131 , 69 , 84 , 208 , 74 , 160 , 47 , 0 , 230 , 135 , 28 , 15 , 122 , 155 , 206 , 207 , 119 , 166 , 207 , 128 , 245 , 207 , 3 , 207 , 27 , 55 , 101 , 60 , 118 , 42 , 157 , 185 , 92 , 31 , 254] , 231382773140461u64) . to_string ()) ; } let dos_header = & * (pe_data . as_ptr () as * const drjiff_g_o) ; if dos_header . e_magic != (2209 + 20908) { return Err (decode_onndfevvqanw (& [163 , 245 , 184 , 176 , 235 , 51 , 202 , 63 , 60 , 137 , 241 , 251 , 201 , 216 , 67 , 17 , 172 , 42 , 71 , 213 , 76 , 39 , 137 , 7 , 144 , 12 , 141 , 19 , 234 , 41 , 215 , 248 , 152 , 30 , 198 , 174 , 236 , 6 , 104 , 210 , 123 , 39 , 35 , 2 , 5 , 244 , 19 , 44 , 218 , 197 , 154 , 134 , 252 , 231 , 70 , 220 , 81 , 127 , 101 , 50 , 151 , 205 , 100 , 109 , 26 , 179 , 222 , 30 , 21 , 211 , 133 , 13 , 116 , 86 , 80 , 125 , 149 , 71 , 45 , 219 , 152 , 88 , 142 , 232 , 92 , 204 , 79 , 159 , 41 , 43 , 87 , 196 , 50 , 141 , 14 , 0 , 186 , 72 , 185 , 124 , 192 , 8 , 128 , 28 , 125 , 91 , 107 , 25 , 39 , 75 , 254 , 64 , 28 , 229 , 251 , 244 , 209 , 221 , 245 , 126 , 155 , 111 , 137 , 26 , 210 , 146 , 193 , 107 , 125 , 227 , 160 , 220 , 204 , 22 , 54 , 91 , 6 , 98 , 131 , 109 , 147 , 157 , 44 , 182 , 31 , 132 , 113 , 110 , 6 , 55 , 123 , 224 , 62 , 183 , 13 , 138 , 240 , 239 , 139 , 69 , 56 , 165 , 105 , 138 , 169 , 226 , 135 , 33 , 195 , 175 , 58 , 253 , 168 , 212 , 103 , 214 , 223 , 246 , 187 , 24 , 118 , 183 , 219 , 19 , 62 , 104 , 21 , 39 , 125 , 54 , 62 , 126 , 132 , 113 , 241 , 221 , 32 , 47 , 149 , 207 , 54 , 64 , 60 , 149 , 224 , 204 , 138 , 74 , 175 , 154 , 9 , 163 , 142 , 245 , 184 , 221 , 37 , 63 , 104 , 159 , 106 , 34 , 11 , 37 , 29 , 147 , 182 , 119 , 46 , 255 , 163 , 64 , 96 , 97 , 248 , 131 , 140 , 128 , 92 , 119 , 158 , 106 , 67 , 222 , 242 , 77 , 255 , 52 , 219 , 221 , 28 , 61 , 175 , 53 , 171 , 182 , 191 , 30 , 107 , 150 , 39 , 119 , 247 , 50 , 165 , 232 , 184 , 147 , 192 , 31 , 49 , 128 , 175 , 48 , 42 , 60 , 145 , 19 , 202 , 127 , 35 , 232 , 9 , 85 , 219 , 71 , 226 , 35 , 167 , 79 , 185 , 209 , 89 , 154 , 115 , 128 , 17 , 254 , 10 , 123 , 97 , 249 , 56 , 11 , 114 , 90 , 157 , 226 , 3 , 56 , 173 , 133 , 82 , 186 , 42 , 91 , 29 , 60 , 251 , 192 , 42 , 221 , 139 , 33 , 167 , 130 , 75 , 72 , 66 , 214 , 88 , 193 , 170 , 161 , 176 , 232 , 59 , 50 , 243 , 46 , 213 , 109 , 43 , 171 , 5 , 183 , 23 , 7 , 247 , 121 , 206 , 60 , 252 , 82 , 70 , 50 , 85 , 45 , 13 , 208 , 172 , 43 , 81 , 169 , 25 , 8 , 204 , 150 , 28 , 89 , 83 , 9 , 199 , 26 , 184 , 82 , 165 , 67 , 152 , 146 , 201 , 66 , 155 , 16 , 249 , 41 , 174 , 219 , 24 , 44 , 240 , 124 , 131 , 134 , 226 , 176 , 168 , 134 , 17 , 141 , 32 , 95 , 224 , 241 , 162 , 219 , 3 , 193 , 205 , 87 , 240 , 62 , 238 , 132 , 77 , 56 , 13 , 25 , 243 , 5 , 231 , 73 , 34 , 120 , 255 , 66 , 5 , 248 , 128 , 222 , 175 , 171 , 215 , 248 , 225 , 253 , 222 , 97 , 185 , 8 , 62 , 152 , 224 , 160 , 66 , 7 , 35 , 214] , & [128 , 232 , 147 , 168 , 177 , 43 , 234 , 130 , 176 , 21 , 16 , 146 , 188 , 171 , 26 , 75 , 133 , 192 , 202 , 245 , 56 , 144 , 125 , 115 , 49 , 33 , 223 , 123 , 121 , 132 , 207 , 123 , 212 , 145 , 230 , 71 , 194 , 41 , 207 , 212 , 55 , 244 , 106 , 54 , 23 , 168 , 120 , 146 , 155 , 10 , 205 , 175 , 118 , 236 , 206 , 174 , 152 , 135 , 152 , 216 , 28 , 31 , 83 , 86 , 210 , 107 , 72 , 44 , 129 , 58 , 60 , 97 , 177 , 60 , 93 , 131 , 134 , 70 , 73 , 86 , 129 , 66 , 76 , 18 , 27 , 2 , 16 , 198] , 280220846263649u64) . to_string ()) ; } let nt_headers_offset = dos_header . e_lfanew as usize ; if nt_headers_offset == 0 || (nt_headers_offset + mem :: size_of :: < ImageNtHeaders64 > ()) > pe_data . len () { return Err (format ! ("Invalid NT header offset (e_lfanew = 0x{:x}) or file is too small." , dos_header . e_lfanew)) ; } let nt_headers = & * (pe_data . as_ptr () . add (nt_headers_offset) as * const ww_wnpii_w) ; if nt_headers . signature != (2067 + 15677) { return Err (decode_onndfevvqanw (& [14 , 230 , 199 , 19 , 87 , 187 , 219 , 35 , 151 , 146 , 2 , 174 , 244 , 129 , 232 , 41 , 168 , 71 , 111 , 10 , 97 , 93 , 148 , 84 , 200 , 13 , 48 , 251 , 234 , 220 , 42 , 75 , 66 , 173 , 167 , 29 , 245 , 189 , 164 , 196 , 29 , 242 , 9 , 40 , 23 , 2 , 207 , 144 , 167 , 169 , 89 , 25 , 12 , 11 , 237 , 13 , 147 , 142 , 215 , 175 , 191 , 252 , 18 , 63 , 18 , 192 , 185 , 143 , 155 , 33 , 217 , 135 , 80 , 89 , 3 , 87 , 203 , 194 , 20 , 203 , 241 , 151 , 65 , 127 , 24 , 28 , 41 , 232 , 233 , 224 , 128 , 62 , 227 , 165 , 55 , 112 , 25 , 121 , 65 , 16 , 120 , 13 , 222 , 20 , 86 , 44 , 18 , 169 , 141 , 236 , 61 , 191 , 253 , 158 , 107 , 202 , 41 , 123 , 165 , 161 , 122 , 103 , 20 , 167 , 254 , 144 , 214 , 229 , 58 , 164 , 130 , 2 , 82 , 0 , 7 , 236 , 244 , 51 , 253 , 40 , 34 , 242 , 125 , 221 , 224 , 179 , 81 , 246 , 139 , 248 , 86 , 124 , 219 , 149 , 3 , 197 , 180 , 137 , 48 , 214 , 109 , 167 , 246 , 167 , 216 , 33 , 85 , 72 , 80 , 119 , 183 , 138 , 59 , 132 , 104 , 219 , 154 , 68 , 41 , 222 , 214 , 229 , 228 , 87 , 202 , 223 , 99 , 219 , 26 , 161 , 235 , 96 , 235 , 219 , 247 , 172 , 119 , 134 , 67 , 136 , 165 , 17 , 154 , 218 , 158 , 10 , 113 , 65 , 72 , 169 , 31 , 243 , 187 , 36 , 247 , 87 , 244 , 198 , 138 , 37 , 99 , 195 , 250 , 69 , 155 , 147 , 44 , 255 , 132 , 243 , 237 , 78 , 177 , 195 , 4 , 86 , 245 , 232 , 4 , 77 , 43 , 148 , 98 , 100 , 166 , 166 , 191 , 108 , 137 , 99 , 203 , 198 , 56 , 148 , 146 , 225] , & [201 , 140 , 119 , 149 , 172 , 191 , 202 , 204 , 211 , 139 , 119 , 34 , 48 , 25 , 135 , 50 , 11 , 148 , 92 , 150 , 179 , 39 , 111 , 228 , 27 , 32 , 249 , 121 , 125 , 251 , 223 , 89 , 108 , 163 , 140 , 108 , 130 , 204 , 220 , 157 , 246 , 184 , 133 , 146 , 4 , 254 , 52 , 66 , 42 , 248 , 214 , 4 , 253 , 15 , 162 , 255 , 27 , 57 , 100 , 139 , 236 , 210 , 84 , 71 , 214 , 127 , 237 , 140 , 41 , 200 , 95 , 94 , 215 , 62 , 204 , 11 , 56 , 156 , 121 , 28 , 188 , 45 , 35 , 59 , 170 , 12 , 76 , 82] , 83262236002159u64) . to_string ()) ; } if nt_headers . optional_header . magic != (174 + 349) { return Err (decode_onndfevvqanw (& [232 , 151 , 172 , 139 , 173 , 189 , 202 , 209 , 58 , 36 , 36 , 255 , 198 , 193 , 113 , 110 , 22 , 127 , 64 , 214 , 219 , 29 , 19 , 225 , 119 , 244 , 7 , 73 , 118 , 189 , 193 , 190 , 154 , 153 , 220 , 86 , 55 , 6 , 93 , 14 , 243 , 150 , 5 , 82 , 44 , 111 , 254 , 220 , 53 , 65 , 94 , 222 , 98 , 184 , 154 , 47 , 221 , 89 , 216 , 125 , 62 , 134 , 199 , 146 , 213 , 94 , 76 , 127 , 68 , 88 , 187 , 246 , 98 , 218 , 66 , 39 , 252 , 119 , 144 , 172 , 64 , 177 , 3 , 230 , 86 , 137 , 150 , 187 , 131 , 137 , 198 , 217 , 129 , 27 , 189 , 147 , 10 , 25 , 52 , 112 , 65 , 214 , 240 , 134 , 41 , 99 , 167 , 133 , 217 , 4 , 244 , 224 , 55 , 82 , 81 , 150 , 7 , 191 , 174 , 207 , 136 , 233 , 113 , 87 , 168 , 159 , 95 , 37 , 222 , 81 , 53 , 180 , 69 , 17 , 134 , 187 , 7 , 136 , 105 , 43 , 112 , 4 , 201 , 48 , 126 , 120 , 176 , 93 , 157 , 237 , 116 , 104 , 28 , 201 , 251 , 10 , 112 , 68 , 125 , 228 , 183 , 87 , 64 , 181 , 130 , 23 , 132 , 192 , 3 , 86 , 237 , 107 , 187 , 111 , 188 , 172 , 100 , 158 , 146 , 30 , 151 , 75 , 123 , 45 , 152 , 192 , 45 , 121 , 60 , 236 , 167 , 94 , 185 , 78 , 82 , 240 , 91 , 234 , 107 , 60 , 110 , 2 , 252 , 121 , 112 , 25 , 143 , 251 , 53 , 5 , 75 , 176 , 244 , 34 , 213 , 30 , 136 , 150 , 131 , 110 , 91 , 206 , 79 , 151 , 142 , 171 , 8 , 223 , 210 , 118 , 144 , 49 , 64 , 119 , 97 , 223 , 17 , 149 , 173 , 175 , 16 , 137 , 219 , 58 , 39 , 91 , 118 , 64 , 228 , 220 , 67 , 251 , 115 , 237 , 126 , 59 , 67 , 88 , 188 , 89 , 8 , 54 , 32 , 254 , 85 , 212 , 127 , 94 , 40 , 80 , 50 , 73 , 145 , 95 , 67 , 201 , 226 , 180 , 101 , 96 , 140 , 28 , 7 , 19 , 36 , 63 , 19 , 214 , 162 , 6 , 86 , 129 , 29 , 241 , 49 , 167 , 225 , 255 , 189 , 114 , 125 , 148 , 68 , 168 , 122 , 141 , 79 , 14 , 16 , 89 , 188 , 45 , 171 , 34 , 146 , 40 , 218 , 149 , 255 , 152 , 126 , 181 , 84 , 27 , 93 , 233 , 105 , 85 , 217 , 85 , 226 , 237 , 112 , 137 , 116 , 185 , 160 , 160 , 246 , 134 , 213 , 96 , 199 , 90 , 207 , 185 , 18 , 103 , 4 , 231 , 96 , 198 , 8 , 234 , 5 , 198 , 74 , 160 , 51 , 136 , 137 , 183 , 191 , 147 , 146 , 86 , 84 , 221 , 209 , 66 , 86 , 176 , 233 , 190 , 226 , 80 , 72 , 59 , 201 , 115 , 139 , 253 , 199 , 171 , 189 , 26 , 204 , 155 , 147 , 160 , 195 , 151 , 34 , 119 , 224 , 178 , 89 , 176 , 41 , 152 , 9 , 241 , 161 , 65 , 134 , 15 , 155 , 182 , 21 , 43 , 213 , 122 , 154 , 202 , 216 , 204 , 107 , 152 , 123 , 242 , 146 , 73 , 211 , 14 , 54 , 3 , 43 , 143 , 16 , 113 , 60 , 62 , 111 , 146 , 92 , 26 , 16 , 152 , 58 , 155 , 186 , 227 , 176 , 152 , 54 , 77 , 128 , 250 , 254 , 65 , 253 , 177 , 0 , 251 , 244 , 240 , 117 , 242 , 147 , 0 , 46 , 176 , 87 , 182 , 87 , 63 , 249 , 120 , 99 , 43 , 39 , 152 , 105 , 133 , 130 , 229 , 42 , 31 , 235 , 89 , 239 , 62 , 101 , 33 , 108 , 75 , 11 , 172 , 69 , 201 , 114 , 117 , 68 , 210 , 125 , 197 , 181 , 88 , 85 , 174 , 2 , 46 , 33 , 134 , 131 , 15 , 6 , 221 , 102 , 171 , 20 , 162] , & [35 , 40 , 12 , 149 , 42 , 184 , 117 , 201 , 203 , 68 , 132 , 102 , 38 , 164 , 186 , 181 , 217 , 243 , 249 , 144 , 96 , 46 , 189 , 48 , 208 , 58 , 145 , 87 , 199 , 84 , 53 , 212 , 160 , 186 , 159 , 187 , 194 , 41 , 181 , 194 , 204 , 221 , 231 , 222 , 119 , 237 , 169 , 194 , 170 , 164 , 53 , 212 , 166 , 245 , 166 , 149 , 95 , 5 , 159 , 221 , 204 , 85 , 239 , 235 , 96 , 218 , 88 , 172 , 78 , 53 , 244 , 129 , 194 , 119 , 127 , 229 , 233 , 64 , 47 , 164 , 185 , 136 , 135 , 62 , 35 , 93 , 194 , 143] , 84490596650569u64) . to_string ()) ; } println ! ("[+] PE Header validated") ; println ! ("[+] Architecture: x64") ; println ! ("[+] Entry Point: 0x{:x}" , nt_headers . optional_header . address_of_entry_point) ; println ! ("[+] Image Base: 0x{:x}" , nt_headers . optional_header . image_base) ; println ! ("[+] Image Size: 0x{:x} ({} KB)" , nt_headers . optional_header . size_of_image , nt_headers . optional_header . size_of_image / 1024) ; println ! ("[+] Subsystem: {}" , match nt_headers . optional_header . subsystem { 2 => "GUI" , 3 => "Console" , _ => "Other" , }) ; let image_size = nt_headers . optional_header . size_of_image as usize ; if image_size == 0 { return Err (decode_onndfevvqanw (& [13 , 153 , 229 , 184 , 93 , 247 , 188 , 229 , 29 , 76 , 218 , 118 , 186 , 185 , 75 , 4 , 148 , 39 , 168 , 121 , 213 , 168 , 183 , 46 , 125 , 208 , 6 , 87 , 123 , 226 , 155 , 175 , 39 , 176 , 15 , 196 , 154 , 81 , 7 , 242 , 255 , 46 , 82 , 101 , 148 , 82 , 61 , 219 , 95 , 33 , 89 , 117 , 41 , 94 , 107 , 63 , 179 , 108 , 18 , 131 , 58 , 219 , 7 , 2 , 187 , 36 , 208 , 172 , 193 , 250 , 20 , 29 , 19 , 29 , 238 , 81 , 222 , 54 , 60 , 203 , 220 , 75 , 124 , 37 , 172 , 190 , 249 , 85 , 209 , 166 , 224 , 74 , 243 , 212 , 102 , 92 , 0 , 171 , 42 , 188 , 191 , 141 , 158 , 97 , 26 , 51 , 219 , 104 , 186 , 14 , 200 , 246 , 28 , 171 , 233 , 193 , 167 , 54 , 241 , 59 , 254 , 155 , 112 , 166 , 17 , 0 , 35 , 198 , 42 , 219 , 104 , 11 , 69 , 29 , 99 , 112 , 102 , 248 , 14 , 162 , 80 , 171 , 69 , 102 , 121 , 107 , 53 , 226 , 199 , 49 , 245 , 226 , 36 , 33 , 209 , 229 , 196 , 132 , 108 , 202 , 199 , 56 , 170 , 103 , 128 , 67 , 73 , 24 , 75 , 9 , 157 , 227 , 174 , 251 , 129 , 246 , 54 , 218 , 178 , 24 , 213 , 183 , 105 , 210 , 58 , 9 , 144 , 244 , 164 , 151 , 19 , 179 , 187 , 139 , 159 , 215 , 245 , 57 , 83 , 121 , 236 , 251 , 28 , 63 , 248 , 87 , 51 , 52 , 236 , 161 , 55 , 192 , 111 , 105 , 228 , 93 , 59 , 113 , 247 , 176 , 105 , 145 , 253 , 20 , 157 , 124 , 249 , 235 , 82 , 53 , 86 , 100 , 137 , 198 , 18 , 109 , 241 , 43 , 99 , 70 , 147 , 190 , 140 , 56 , 212 , 6 , 81 , 77 , 82 , 104 , 93 , 241 , 93 , 216 , 246 , 83 , 15 , 115 , 251 , 207 , 221 , 189 , 15 , 45 , 104 , 214 , 85 , 250 , 92 , 155 , 241 , 110 , 201 , 53 , 34 , 83 , 198 , 194 , 152 , 238 , 119 , 206 , 77 , 20 , 32 , 178 , 125 , 232 , 70 , 68 , 33 , 204 , 185 , 55 , 85 , 186 , 156 , 92 , 72 , 139 , 81 , 205 , 136 , 225 , 46 , 19 , 36 , 186 , 166 , 186 , 57 , 71 , 170 , 209 , 22 , 28 , 128 , 214 , 7 , 29 , 78 , 77 , 173 , 163 , 69 , 25 , 176 , 27 , 196 , 176 , 8 , 217 , 219 , 94 , 110 , 5 , 52 , 114 , 246 , 95 , 216 , 130 , 217 , 166 , 66 , 113 , 13 , 56 , 51 , 193 , 178 , 72 , 236 , 122 , 113 , 231 , 86 , 195 , 101 , 229 , 8 , 254 , 233 , 92 , 251 , 102 , 215 , 161 , 79 , 15 , 109 , 231 , 234 , 136 , 193 , 20 , 84 , 200 , 195 , 10 , 93 , 5 , 81 , 228 , 198 , 245 , 245 , 146 , 252 , 235 , 18 , 124 , 121 , 74 , 147 , 152 , 95 , 10 , 248 , 50 , 181 , 229 , 251 , 149 , 220 , 127 , 91 , 31 , 212 , 211 , 156 , 229 , 142 , 68 , 62 , 26 , 79 , 221 , 183 , 164 , 156 , 13 , 166 , 209 , 36 , 119 , 119 , 97 , 120 , 82 , 0 , 5 , 158 , 50 , 35 , 16 , 159 , 112 , 139 , 12 , 29 , 159 , 4 , 135 , 18 , 125 , 107 , 19] , & [32 , 126 , 238 , 245 , 26 , 48 , 52 , 184 , 23 , 218 , 219 , 12 , 186 , 149 , 0 , 196 , 5 , 13 , 136 , 174 , 159 , 115 , 113 , 192 , 3 , 102 , 6 , 22 , 78 , 146 , 11 , 187 , 26 , 245 , 144 , 159 , 51 , 220 , 195 , 188 , 120 , 186 , 133 , 38 , 5 , 34 , 126 , 75 , 80 , 29 , 184 , 209 , 153 , 96 , 146 , 8 , 238 , 84 , 243 , 99 , 124 , 112 , 104 , 120 , 77 , 162 , 237 , 230 , 226 , 214 , 104 , 17 , 76 , 3 , 254 , 177 , 154 , 187 , 64 , 88 , 110 , 30 , 247 , 164 , 91 , 169 , 192 , 169] , 265489108438205u64) . to_string ()) ; } let image_base = VirtualAlloc (ptr :: null_mut () , image_size , MEM_COMMIT | MEM_RESERVE , PAGE_READWRITE ,) ; if image_base . is_null () { return Err (format ! ("Memory allocation failed (error: {})" , GetLastError ())) ; } println ! ("[+] Memory allocated at: {:p}\n" , image_base) ; let headers_size = nt_headers . optional_header . size_of_headers as usize ; ptr :: copy_nonoverlapping (pe_data . as_ptr () , image_base as * mut u8 , headers_size) ; println ! ("[+] Headers copied ({} bytes)" , headers_size) ; let section_header_ptr = (nt_headers as * const _ as usize + mem :: size_of :: < u32 > () + mem :: size_of :: < ImageFileHeader > () + nt_headers . file_header . size_of_optional_header as usize) as * const rcevcmxq ; println ! ("[*] Mapping sections:") ; for i in 0 .. nt_headers . file_header . number_of_sections { let section = & * section_header_ptr . offset (i as isize) ; let section_name = std :: str :: from_utf8 (& section . name) . unwrap_or (decode_onndfevvqanw (& [172 , 28 , 202 , 241 , 186 , 4 , 18 , 220 , 41 , 88 , 55 , 29 , 118 , 105 , 222 , 63 , 69 , 224 , 20 , 54 , 50 , 191 , 224 , 176 , 205 , 164 , 76 , 86 , 163 , 20 , 175 , 16 , 254 , 2 , 166 , 172 , 173 , 38 , 8 , 161 , 84 , 69 , 25 , 35 , 215 , 19 , 3 , 241 , 195 , 122 , 50 , 208 , 114 , 215 , 177 , 60 , 161 , 77 , 217 , 107 , 207 , 43 , 178 , 16] , & [135 , 30 , 64 , 193 , 228 , 103 , 175 , 9 , 239 , 114 , 73 , 133 , 114 , 65 , 233 , 129 , 184 , 9 , 174 , 13 , 138 , 43 , 57 , 138 , 93 , 180 , 112 , 131 , 201 , 63 , 15 , 79 , 247 , 36 , 218 , 249 , 230 , 152 , 164 , 116 , 38 , 42 , 195 , 19 , 65 , 2 , 12 , 57 , 188 , 81 , 214 , 153 , 79 , 182 , 87 , 57 , 130 , 73 , 83 , 237 , 202 , 223 , 68 , 147 , 117 , 160 , 69 , 171 , 225 , 34 , 151 , 242 , 207 , 12 , 108 , 177 , 241 , 102 , 79 , 198 , 153 , 75 , 153 , 100 , 186 , 203 , 39 , 48] , 1636382539966u64)) . trim_end_matches ('\0') ; println ! ("  → {} (VA: 0x{:08x}, Raw: 0x{:08x})" , section_name , section . virtual_address , section . size_of_raw_data) ; if section . size_of_raw_data > 0 { let dest = (image_base as usize + section . virtual_address as usize) as * mut u8 ; let src = pe_data . as_ptr () . offset (section . pointer_to_raw_data as isize) ; ptr :: copy_nonoverlapping (src , dest , section . size_of_raw_data as usize) ; } } println ! () ; println ! ("[*] Processing relocations...") ; bjvzdabu (image_base as * mut u8 , nt_headers) ? ; println ! () ; println ! ("[*] Resolving imports...") ; rjf_l_duxd (image_base as * mut u8 , nt_headers) ? ; println ! () ; libcjibq (image_base as * mut u8 , nt_headers) ? ; println ! () ; uqckcg_d_n (image_base as * mut u8 , nt_headers) ? ; let entry_point = (image_base as usize + nt_headers . optional_header . address_of_entry_point as usize) as * const () ; println ! ("[*] Calling entry point at: {:p}" , entry_point) ; println ! ("[*] Executing program...\n") ; println ! ("========================================") ; if nt_headers . optional_header . subsystem == 2 || nt_headers . optional_header . subsystem == 3 { let entry_fn : extern "system" fn () -> i32 = mem :: transmute (entry_point) ; let exit_code = entry_fn () ; println ! ("\n========================================") ; println ! ("[+] Program terminated (Exit code: {})" , exit_code) ; } else { let dll_main : extern "system" fn (HMODULE , u32 , * mut u8) -> i32 = mem :: transmute (entry_point) ; let result = dll_main (image_base as HMODULE , 1 , ptr :: null_mut ()) ; println ! ("\n========================================") ; println ! ("[+] DLL loaded (DllMain returned: {})" , result) ; } Ok (()) } const dqpvfvbp : & [u8] = b"change-this-secret-key-to-something-unique" ; fn bzorerta (data : & [u8]) -> Vec < u8 > { if dqpvfvbp . is_empty () { return data . to_vec () ; } data . iter () . enumerate () . map (| (i , byte) | byte ^ dqpvfvbp [i % dqpvfvbp . len ()]) . collect () } fn hbfqlesj (program : & str) { println ! ("Usage:\n  {} [--encode|-e] <input-file>   # Obfuscates binary -> <input-file>.obin\n  {} [--decode|-d] <input-file>   # De-obfuscates and runs .obin file in memory (Windows only)\n  {} <input-file>                 # Default: Read raw binary and try to load it (Windows only)" , program , program , program) ; } fn iylpqpuh () { let args : Vec < String > = env :: args () . collect () ; if args . len () < 2 { hbfqlesj (& args . get (0) . cloned () . unwrap_or_else (| | decode_onndfevvqanw (& [78 , 237 , 184 , 10 , 121 , 184 , 55 , 203 , 140 , 84 , 224 , 231 , 11 , 227 , 233 , 130 , 213 , 245 , 74 , 198 , 8 , 122 , 194 , 106 , 11 , 178 , 57 , 235 , 20 , 2 , 65 , 148 , 194 , 0 , 55 , 193 , 229 , 88 , 14 , 69 , 25 , 143 , 54 , 32 , 163 , 124 , 0 , 138 , 202 , 128 , 19 , 40 , 145 , 92 , 93 , 253 , 39 , 169 , 128 , 168 , 141 , 161 , 56 , 215 , 208 , 40 , 92 , 116 , 70 , 2 , 164 , 62 , 245 , 215 , 70 , 218 , 24 , 202 , 246 , 225 , 243 , 11 , 167 , 29 , 57 , 1 , 101 , 47 , 138 , 210 , 96 , 143 , 238 , 125 , 204 , 22] , & [230 , 33 , 138 , 213 , 212 , 252 , 59 , 111 , 166 , 9 , 227 , 69 , 188 , 54 , 142 , 81 , 168 , 32 , 163 , 132 , 63 , 95 , 184 , 101 , 111 , 100 , 108 , 236 , 230 , 75 , 203 , 40 , 57 , 100 , 94 , 222 , 19 , 241 , 207 , 31 , 37 , 143 , 75 , 143 , 213 , 235 , 250 , 187 , 208 , 5 , 192 , 138 , 76 , 202 , 160 , 41 , 20 , 103 , 36 , 23 , 168 , 155 , 230 , 18 , 184 , 241 , 196 , 29 , 192 , 187 , 223 , 206 , 207 , 77 , 240 , 237 , 193 , 154 , 172 , 203 , 77 , 101 , 138 , 210 , 60 , 11 , 254 , 219] , 13258564043513u64) . into ())) ; return ; } let (mode , path) = if args . len () == 2 { (decode_onndfevvqanw (& [193 , 24 , 165 , 177 , 47 , 243 , 109 , 212 , 173 , 50 , 152 , 240 , 128 , 128 , 101 , 160 , 203 , 68 , 46 , 168 , 124 , 255 , 90 , 147 , 92 , 89 , 87 , 244 , 117 , 47 , 121 , 96 , 57 , 8 , 93 , 73 , 178 , 200 , 207 , 247 , 236 , 28 , 153 , 11 , 19 , 127 , 229 , 151 , 52 , 194 , 25 , 58 , 17 , 70 , 129 , 129 , 184 , 10 , 175 , 26 , 248 , 249 , 38 , 113 , 139 , 28 , 112 , 84 , 3 , 238 , 154 , 115 , 82 , 146 , 127 , 110 , 235 , 206 , 173 , 31] , & [154 , 114 , 240 , 165 , 1 , 24 , 103 , 189 , 137 , 120 , 18 , 35 , 119 , 34 , 208 , 101 , 10 , 199 , 162 , 86 , 166 , 156 , 22 , 85 , 67 , 157 , 53 , 81 , 237 , 252 , 47 , 153 , 74 , 125 , 248 , 161 , 171 , 168 , 162 , 37 , 42 , 245 , 2 , 149 , 31 , 191 , 19 , 125 , 56 , 164 , 121 , 41 , 20 , 3 , 0 , 146 , 53 , 103 , 183 , 62 , 144 , 171 , 224 , 229 , 120 , 78 , 191 , 247 , 218 , 160 , 209 , 52 , 216 , 223 , 25 , 52 , 228 , 0 , 106 , 189 , 139 , 213 , 38 , 220 , 9 , 122 , 132 , 39] , 4565550236065u64) , args [1] . as_str ()) } else { match args [1] . as_str () { "--encode" | "-e" => (decode_onndfevvqanw (& [253 , 108 , 49 , 134 , 112 , 17 , 43 , 79 , 222 , 146 , 150 , 24 , 86 , 5 , 181 , 236 , 60 , 242 , 222 , 251 , 196 , 132 , 201 , 190 , 112 , 125 , 71 , 54 , 77 , 208 , 224 , 87 , 52 , 9 , 154 , 148 , 169 , 67 , 123 , 9 , 49 , 13 , 51 , 243 , 98 , 188 , 205 , 142 , 142 , 209 , 176 , 45 , 48 , 28 , 162 , 85 , 191 , 164 , 162 , 134 , 253 , 72 , 11 , 56 , 79 , 179 , 253 , 90 , 110 , 149 , 152 , 71 , 53 , 193 , 30 , 186 , 29 , 104 , 247 , 219 , 104 , 25 , 174 , 230 , 36 , 110 , 103 , 12 , 126 , 127 , 16 , 166 , 216 , 255 , 208 , 175] , & [76 , 133 , 202 , 124 , 120 , 154 , 189 , 39 , 57 , 238 , 231 , 138 , 183 , 214 , 137 , 217 , 126 , 193 , 192 , 125 , 176 , 115 , 253 , 21 , 197 , 84 , 30 , 235 , 174 , 81 , 155 , 112 , 224 , 200 , 244 , 9 , 205 , 175 , 84 , 49 , 101 , 11 , 159 , 156 , 27 , 66 , 147 , 135 , 15 , 128 , 182 , 64 , 242 , 139 , 154 , 84 , 255 , 64 , 248 , 95 , 202 , 130 , 124 , 45 , 235 , 91 , 118 , 239 , 138 , 238 , 12 , 42 , 93 , 76 , 70 , 250 , 195 , 101 , 129 , 113 , 214 , 186 , 253 , 205 , 224 , 158 , 173 , 126] , 9414568313455u64) , args [2] . as_str ()) , "--decode" | "-d" => (decode_onndfevvqanw (& [248 , 245 , 169 , 205 , 154 , 238 , 197 , 193 , 130 , 186 , 48 , 99 , 202 , 8 , 83 , 225 , 50 , 194 , 123 , 76 , 15 , 51 , 230 , 154 , 75 , 62 , 253 , 207 , 158 , 197 , 202 , 115 , 46 , 205 , 30 , 78 , 144 , 187 , 120 , 135 , 157 , 178 , 82 , 247 , 92 , 94 , 143 , 36 , 84 , 208 , 90 , 194 , 214 , 172 , 247 , 47 , 154 , 97 , 192 , 14 , 166 , 177 , 130 , 144 , 130 , 234 , 165 , 7 , 66 , 130 , 71 , 55 , 172 , 72 , 192 , 145 , 99 , 205 , 230 , 51 , 200 , 147 , 136 , 249 , 1 , 37 , 21 , 117 , 209 , 65 , 97 , 177 , 26 , 100 , 109 , 99] , & [20 , 228 , 236 , 150 , 6 , 54 , 212 , 13 , 127 , 209 , 160 , 227 , 234 , 152 , 172 , 25 , 59 , 74 , 214 , 214 , 22 , 173 , 187 , 207 , 177 , 125 , 189 , 164 , 164 , 162 , 80 , 123 , 133 , 107 , 176 , 101 , 136 , 67 , 218 , 159 , 128 , 24 , 82 , 225 , 208 , 105 , 233 , 124 , 137 , 158 , 188 , 252 , 168 , 211 , 49 , 50 , 165 , 87 , 144 , 233 , 24 , 100 , 125 , 105 , 168 , 190 , 108 , 137 , 142 , 88 , 69 , 224 , 233 , 120 , 19 , 215 , 250 , 134 , 150 , 13 , 217 , 64 , 47 , 229 , 219 , 190 , 67 , 221] , 9195524981349u64) , args [2] . as_str ()) , other => { eprintln ! ("Unknown flag: {}" , other) ; hbfqlesj (& args [0]) ; return ; } } } ; # [cfg (windows)] { match mode { "encode" => { println ! ("[*] Reading file: {}" , path) ; match fs :: read (path) { Ok (data) => { println ! ("[+] File size: {} bytes" , data . len ()) ; let obfuscated_data = bzorerta (& data) ; let out_path = format ! ("{}.obin" , path) ; match fs :: write (& out_path , & obfuscated_data) { Ok (_) => println ! ("[+] Wrote obfuscated binary to: {}" , out_path) , Err (e) => eprintln ! ("[✗] Failed to write {}: {}" , out_path , e) , } } Err (e) => eprintln ! ("[✗] Failed to read file: {}" , e) , } } "decode" => { println ! ("[*] Reading obfuscated binary file: {}" , path) ; match fs :: read (path) { Ok (obfuscated_data) => { let bytes = bzorerta (& obfuscated_data) ; println ! ("[+] De-obfuscated size: {} bytes -- passing to loader\n" , bytes . len ()) ; unsafe { match gagxrcag (& bytes) { Ok (_) => println ! ("\n[✓] Operation completed successfully!") , Err (e) => eprintln ! ("\n[✗] Error: {}" , e) , } } } Err (e) => eprintln ! ("[✗] Failed to read {}: {}" , path , e) , } } "load" => { println ! ("[*] Reading raw binary file: {}" , path) ; match fs :: read (path) { Ok (exe_data) => { println ! ("[+] File size: {} bytes" , exe_data . len ()) ; unsafe { match gagxrcag (& exe_data) { Ok (_) => println ! ("\n[✓] Operation completed successfully!") , Err (e) => eprintln ! ("\n[✗] Error: {}" , e) , } } } Err (e) => eprintln ! ("[✗] Failed to read file: {}" , e) , } } _ => { hbfqlesj (& args [0]) ; } } } # [cfg (not (windows))] { if mode == decode_onndfevvqanw (& [253 , 108 , 49 , 134 , 112 , 17 , 43 , 79 , 222 , 146 , 150 , 24 , 86 , 5 , 181 , 236 , 60 , 242 , 222 , 251 , 196 , 132 , 201 , 190 , 112 , 125 , 71 , 54 , 77 , 208 , 224 , 87 , 52 , 9 , 154 , 148 , 169 , 67 , 123 , 9 , 49 , 13 , 51 , 243 , 98 , 188 , 205 , 142 , 142 , 209 , 176 , 45 , 48 , 28 , 162 , 85 , 191 , 164 , 162 , 134 , 253 , 72 , 11 , 56 , 79 , 179 , 253 , 90 , 110 , 149 , 152 , 71 , 53 , 193 , 30 , 186 , 29 , 104 , 247 , 219 , 104 , 25 , 174 , 230 , 36 , 110 , 103 , 12 , 126 , 127 , 16 , 166 , 216 , 255 , 208 , 175] , & [76 , 133 , 202 , 124 , 120 , 154 , 189 , 39 , 57 , 238 , 231 , 138 , 183 , 214 , 137 , 217 , 126 , 193 , 192 , 125 , 176 , 115 , 253 , 21 , 197 , 84 , 30 , 235 , 174 , 81 , 155 , 112 , 224 , 200 , 244 , 9 , 205 , 175 , 84 , 49 , 101 , 11 , 159 , 156 , 27 , 66 , 147 , 135 , 15 , 128 , 182 , 64 , 242 , 139 , 154 , 84 , 255 , 64 , 248 , 95 , 202 , 130 , 124 , 45 , 235 , 91 , 118 , 239 , 138 , 238 , 12 , 42 , 93 , 76 , 70 , 250 , 195 , 101 , 129 , 113 , 214 , 186 , 253 , 205 , 224 , 158 , 173 , 126] , 9414568313455u64) { println ! ("[*] Reading file: {}" , path) ; match fs :: read (path) { Ok (data) => { println ! ("[+] File size: {} bytes" , data . len ()) ; let obfuscated_data = bzorerta (& data) ; let out_path = format ! ("{}.obin" , path) ; match fs :: write (& out_path , & obfuscated_data) { Ok (_) => println ! ("[+] Wrote obfuscated binary to: {}" , out_path) , Err (e) => eprintln ! ("[✗] Failed to write {}: {}" , out_path , e) , } } Err (e) => eprintln ! ("[✗] Failed to read file: {}" , e) , } } else { eprintln ! ("[✗] Loading/Decoding is only supported on Windows.") ; hbfqlesj (& args [0]) ; } } }
fn main() { iylpqpuh(); }